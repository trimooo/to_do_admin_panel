{"version":3,"sources":["../../src/dataProvider/index.ts","../../src/utils/index.ts","../../src/utils/graphql.ts","../../src/liveProvider/index.ts","../../src/index.ts","../../../../node_modules/graphql-request/src/index.ts"],"sourcesContent":["import { BaseRecord, DataProvider, LogicalFilter } from \"@refinedev/core\";\n\nimport camelcase from \"camelcase\";\nimport * as gql from \"gql-query-builder\";\nimport VariableOptions from \"gql-query-builder/build/VariableOptions\";\nimport { GraphQLClient } from \"graphql-request\";\nimport gqlTag from \"graphql-tag\";\nimport { singular } from \"pluralize\";\n\nimport { generateFilters, generatePaging, generateSorting } from \"../utils\";\n\nimport { getOperationFields, isMutation } from \"../utils/graphql\";\n\nconst dataProvider = (client: GraphQLClient): Required<DataProvider> => {\n  return {\n    getList: async ({ resource, pagination, sorters, filters, meta }) => {\n      const operation = camelcase(resource);\n\n      const paging = generatePaging(pagination || {});\n\n      const queryVariables: VariableOptions = {};\n\n      let query;\n      let variables;\n\n      if (meta?.gqlQuery) {\n        query = meta?.gqlQuery;\n\n        variables = {\n          filter: filters ? generateFilters(filters as LogicalFilter[]) : {},\n          sorting: sorters ? generateSorting(sorters) : [],\n          paging,\n        };\n      } else {\n        if (filters) {\n          queryVariables[\"filter\"] = {\n            type: camelcase(`${singular(resource)}Filter`, {\n              pascalCase: true,\n            }),\n            required: true,\n            value: generateFilters(filters as LogicalFilter[]),\n          };\n        }\n\n        if (sorters) {\n          queryVariables[\"sorting\"] = {\n            type: camelcase(`${singular(resource)}Sort`, {\n              pascalCase: true,\n            }),\n            required: true,\n            list: [true],\n            value: generateSorting(sorters),\n          };\n        }\n\n        if (paging) {\n          queryVariables[\"paging\"] = {\n            type: \"OffsetPaging\",\n            required: true,\n            value: paging,\n          };\n        }\n\n        const gqlQuery = gql.query({\n          operation,\n          fields: [{ nodes: meta?.fields }, \"totalCount\"],\n          variables: queryVariables,\n        });\n\n        query = gqlQuery.query;\n        variables = gqlQuery.variables;\n      }\n\n      const response = await client.request<BaseRecord>(query, variables);\n\n      return {\n        data: response[operation].nodes,\n        total: response[operation].totalCount,\n      };\n    },\n\n    getMany: async ({ resource, ids, meta }) => {\n      const operation = camelcase(resource);\n\n      if (meta?.gqlQuery) {\n        const response = await client.request<BaseRecord>(meta.gqlQuery, {\n          filter: {\n            id: { in: ids },\n          },\n        });\n\n        return {\n          data: response[operation].nodes,\n        };\n      }\n\n      const { query, variables } = gql.query({\n        operation,\n        fields: [{ nodes: meta?.fields || [\"id\"] }],\n        variables: {\n          filter: {\n            type: camelcase(`${singular(resource)}Filter`, {\n              pascalCase: true,\n            }),\n            required: true,\n            value: {\n              id: { in: ids },\n            },\n          },\n        },\n      });\n\n      const response = await client.request<BaseRecord>(query, variables);\n\n      return {\n        data: response[operation].nodes,\n      };\n    },\n\n    create: async ({ resource, variables, meta }) => {\n      const operation = `createOne${camelcase(singular(resource), {\n        pascalCase: true,\n      })}`;\n\n      const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n      if (gqlOperation) {\n        const response = await client.request<BaseRecord>(gqlOperation, {\n          input: { [camelcase(singular(resource))]: variables },\n        });\n\n        return {\n          data: response[operation],\n        };\n      }\n\n      const { query, variables: queryVariables } = gql.mutation({\n        operation,\n        fields: meta?.fields || [\"id\"],\n        variables: {\n          input: {\n            type: `CreateOne${camelcase(singular(resource), {\n              pascalCase: true,\n            })}Input`,\n            required: true,\n            value: {\n              [camelcase(singular(resource))]: variables,\n            },\n          },\n        },\n      });\n\n      const response = await client.request<BaseRecord>(query, queryVariables);\n\n      return {\n        data: response[operation],\n      };\n    },\n\n    createMany: async ({ resource, variables, meta }) => {\n      const pascalResource = camelcase(resource, { pascalCase: true });\n      const operation = `createMany${pascalResource}`;\n\n      const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n      if (gqlOperation) {\n        const response = await client.request<BaseRecord>(gqlOperation, {\n          input: {\n            [camelcase(resource)]: variables,\n          },\n        });\n\n        return {\n          data: response[operation],\n        };\n      }\n\n      const { query, variables: queryVariables } = gql.mutation({\n        operation,\n        fields: meta?.fields || [\"id\"],\n        variables: {\n          input: {\n            type: `CreateMany${camelcase(resource, {\n              pascalCase: true,\n            })}Input`,\n            required: true,\n            value: {\n              [camelcase(resource)]: variables,\n            },\n          },\n        },\n      });\n\n      const response = await client.request<BaseRecord>(query, queryVariables);\n\n      return {\n        data: response[operation],\n      };\n    },\n    update: async ({ resource, id, variables, meta }) => {\n      const operation = `updateOne${camelcase(singular(resource), {\n        pascalCase: true,\n      })}`;\n\n      const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n      if (gqlOperation) {\n        const response = await client.request<BaseRecord>(gqlOperation, {\n          input: {\n            id,\n            update: variables,\n          },\n        });\n\n        return {\n          data: response[operation],\n        };\n      }\n\n      const { query, variables: queryVariables } = gql.mutation({\n        operation,\n        fields: meta?.fields || [\"id\"],\n        variables: {\n          input: {\n            type: `UpdateOne${camelcase(singular(resource), {\n              pascalCase: true,\n            })}Input`,\n            required: true,\n            value: {\n              id,\n              update: variables,\n            },\n          },\n        },\n      });\n\n      const response = await client.request<BaseRecord>(query, queryVariables);\n\n      return {\n        data: response[operation],\n      };\n    },\n    updateMany: async ({ resource, ids, variables, meta }) => {\n      const pascalResource = camelcase(resource, {\n        pascalCase: true,\n      });\n\n      const mutationOperation = `updateMany${pascalResource}`;\n\n      const mutation = gqlTag`\n                mutation UpdateMany${pascalResource}($input: UpdateMany${pascalResource}Input!) {\n                    ${mutationOperation}(input: $input) {\n                        updatedCount\n                    }\n                }\n            `;\n\n      await client.request<BaseRecord>(mutation, {\n        input: { filter: { id: { in: ids } }, update: variables },\n      });\n\n      const operation = camelcase(resource);\n\n      let query;\n      let queryVariables;\n\n      if (meta?.fields) {\n        const gqlQuery = gql.query({\n          operation,\n          fields: [{ nodes: meta?.fields || [\"id\"] }],\n          variables: {\n            filter: {\n              type: camelcase(`${singular(resource)}Filter`, {\n                pascalCase: true,\n              }),\n              required: true,\n              value: {\n                id: { in: ids },\n              },\n            },\n          },\n        });\n        query = gqlQuery.query;\n        queryVariables = gqlQuery.variables;\n      } else {\n        query = gqlTag`\n                    query GetMany${pascalResource}($filter: ${singular(\n                      pascalResource,\n                    )}Filter!) {\n                        ${operation}(filter: $filter) {\n                            nodes {\n                                id\n                            }\n                        }\n                    }\n                `;\n\n        queryVariables = {\n          filter: { id: { in: ids } },\n        };\n      }\n\n      const response = await client.request<BaseRecord>(query, queryVariables);\n\n      return {\n        data: response[operation].nodes,\n      };\n    },\n    getOne: async ({ resource, id, meta }) => {\n      const operation = camelcase(singular(resource));\n\n      const gqlOperation = meta?.gqlQuery ?? meta?.gqlMutation;\n\n      if (gqlOperation) {\n        let query = gqlOperation;\n        const variables = { id };\n\n        if (isMutation(gqlOperation)) {\n          const stringFields = getOperationFields(gqlOperation);\n\n          query = gqlTag`\n                        query Get${camelcase(singular(resource), {\n                          pascalCase: true,\n                        })}($id: ID!) {\n                            ${operation}(id: $id) {\n                            ${stringFields}\n                            }\n                        }\n                    `;\n        }\n\n        const response = await client.request<BaseRecord>(query, variables);\n\n        return {\n          data: response[operation],\n        };\n      }\n\n      const { query, variables } = gql.query({\n        operation,\n        fields: meta?.fields || [\"id\"],\n        variables: {\n          id: {\n            type: \"ID\",\n            required: true,\n            value: id,\n          },\n        },\n      });\n\n      const response = await client.request<BaseRecord>(query, variables);\n\n      return {\n        data: response[operation],\n      };\n    },\n    deleteOne: async ({ resource, id, meta }) => {\n      const pascalResource = camelcase(singular(resource), {\n        pascalCase: true,\n      });\n\n      const operation = `deleteOne${pascalResource}`;\n\n      if (meta?.gqlMutation) {\n        const response = await client.request<BaseRecord>(meta.gqlMutation, {\n          input: { id },\n        });\n\n        return {\n          data: response[operation],\n        };\n      }\n\n      const query = gqlTag`\n                    mutation DeleteOne${pascalResource}($input: DeleteOne${pascalResource}Input!) {\n                        ${operation}(input: $input) {\n                            id\n                        }\n                    }\n                `;\n\n      const response = await client.request<BaseRecord>(query, {\n        input: { id },\n      });\n\n      return {\n        data: response[operation],\n      };\n    },\n    deleteMany: async ({ resource, ids }) => {\n      const pascalResource = camelcase(resource, {\n        pascalCase: true,\n      });\n      const operation = `deleteMany${pascalResource}`;\n\n      const query = gqlTag`\n                mutation DeleteMany${pascalResource}($input: DeleteMany${pascalResource}Input!) {\n                    ${operation}(input: $input) {\n                        deletedCount\n                    }\n                }\n            `;\n\n      const variables = {\n        input: {\n          filter: {\n            id: { in: ids },\n          },\n        },\n      };\n\n      await client.request<BaseRecord>(query, variables);\n\n      return {\n        data: [],\n      };\n    },\n    getApiUrl: () => {\n      throw Error(\"Not implemented on refine-nestjs-query data provider.\");\n    },\n    custom: async ({ url, method, headers, meta }) => {\n      if (url) {\n        client.setEndpoint(url);\n      }\n\n      if (headers) {\n        client.setHeaders(headers);\n      }\n\n      const gqlOperation = meta?.gqlMutation ?? meta?.gqlQuery;\n\n      if (gqlOperation) {\n        const response: any = await client.request(\n          gqlOperation,\n          meta?.variables ?? {},\n        );\n\n        return { data: response };\n      }\n\n      if (meta?.rawQuery) {\n        const response = await client.request<BaseRecord>(\n          meta.rawQuery,\n          meta.variables,\n        );\n\n        return { data: response };\n      }\n\n      if (meta) {\n        if (meta.operation) {\n          let query;\n          let variables;\n\n          if (method === \"get\") {\n            const gqlQuery = gql.query({\n              operation: meta.operation,\n              fields: meta.fields,\n              variables: meta.variables,\n            });\n\n            query = gqlQuery.query;\n            variables = gqlQuery.variables;\n          } else {\n            const gqlMutation = gql.mutation({\n              operation: meta.operation,\n              fields: meta.fields,\n              variables: meta.variables,\n            });\n\n            query = gqlMutation.query;\n            variables = gqlMutation.variables;\n          }\n\n          const response = await client.request<BaseRecord>(query, variables);\n\n          return {\n            data: response[meta.operation],\n          };\n        }\n        throw Error(\"GraphQL operation name required.\");\n      }\n      throw Error(\n        \"GraphQL needs operation, fields and variables values in meta object.\",\n      );\n    },\n  };\n};\n\nexport default dataProvider;\n","import {\n  CrudFilter,\n  CrudOperators,\n  CrudSorting,\n  LogicalFilter,\n  Pagination,\n} from \"@refinedev/core\";\n\nimport camelcase from \"camelcase\";\nimport * as gql from \"gql-query-builder\";\nimport VariableOptions from \"gql-query-builder/build/VariableOptions\";\nimport { Client } from \"graphql-ws\";\nimport set from \"lodash/set\";\nimport { singular } from \"pluralize\";\n\nimport { getOperationFields } from \"./graphql\";\n\nexport const generateSubscription = (\n  client: Client,\n  { callback, params, meta }: any,\n  type: string,\n) => {\n  const generatorMap: any = {\n    created: generateCreatedSubscription,\n    updated: generateUpdatedSubscription,\n    deleted: generateDeletedSubscription,\n  };\n\n  const { resource, filters, subscriptionType, id, ids } = params ?? {};\n\n  const generator = generatorMap[type];\n\n  const { operation, query, variables, operationName } = generator({\n    ids,\n    id,\n    resource,\n    filters,\n    meta,\n    subscriptionType,\n  });\n\n  const onNext = (payload: any) => {\n    callback(payload.data[operation]);\n  };\n\n  const unsubscribe = client.subscribe(\n    { query, variables, operationName },\n    {\n      next: onNext,\n      error: console.error,\n      complete: () => null,\n    },\n  );\n\n  return unsubscribe;\n};\n\nconst operatorMap: { [key: string]: string } = {\n  eq: \"eq\",\n  ne: \"neq\",\n  lt: \"lt\",\n  gt: \"gt\",\n  lte: \"lte\",\n  gte: \"gte\",\n  in: \"in\",\n  nin: \"notIn\",\n};\n\nconst operatorMapper = (\n  operator: CrudOperators,\n  value: any,\n): { [key: string]: any } => {\n  if (operator === \"contains\") {\n    return { iLike: `%${value}%` };\n  }\n\n  if (operator === \"ncontains\") {\n    return { notILike: `%${value}%` };\n  }\n\n  if (operator === \"startswith\") {\n    return { iLike: `${value}%` };\n  }\n\n  if (operator === \"nstartswith\") {\n    return { notILike: `${value}%` };\n  }\n\n  if (operator === \"endswith\") {\n    return { iLike: `%${value}` };\n  }\n\n  if (operator === \"nendswith\") {\n    return { notILike: `%${value}` };\n  }\n\n  if (operator === \"null\") {\n    return { is: null };\n  }\n\n  if (operator === \"nnull\") {\n    return { isNot: null };\n  }\n\n  if (operator === \"between\") {\n    if (!Array.isArray(value)) {\n      throw new Error(\"Between operator requires an array\");\n    }\n\n    if (value.length !== 2) {\n      return {};\n    }\n\n    return { between: { lower: value[0], upper: value[1] } };\n  }\n\n  return { [operatorMap[operator]]: value };\n};\n\nexport const generateFilters = (filters: LogicalFilter[]) => {\n  const result: { [key: string]: { [key: string]: string | number } } = {};\n\n  filters\n    .filter((f) => {\n      if (Array.isArray(f.value) && f.value.length === 0) {\n        return false;\n      }\n\n      return !!f.value;\n    })\n    .map((filter: LogicalFilter | CrudFilter) => {\n      if (filter.operator === \"and\" || filter.operator === \"or\") {\n        return set(result, filter.operator, [\n          generateFilters(filter.value as LogicalFilter[]),\n        ]);\n      }\n      if (\"field\" in filter) {\n        return set(\n          result,\n          filter.field,\n          operatorMapper(filter.operator, filter.value),\n        );\n      }\n      return {};\n    });\n\n  return result;\n};\n\nexport const generateSorting = (sorters: CrudSorting) => {\n  return sorters.map((sorter) => {\n    return {\n      field: sorter.field,\n      direction: sorter.order.toUpperCase(),\n    };\n  });\n};\n\nexport const generatePaging = (pagination: Pagination) => {\n  // maximum value of 32 bit signed integer\n  if (pagination.mode === \"off\") return { limit: 2147483647 };\n\n  if (pagination.mode !== \"server\") return undefined;\n\n  if (!pagination.current || !pagination.pageSize) return undefined;\n\n  return {\n    limit: pagination.pageSize,\n    offset: (pagination.current - 1) * pagination.pageSize,\n  };\n};\n\nexport const generateCreatedSubscription = ({\n  resource,\n  filters,\n  meta,\n}: any) => {\n  const gqlOperation = meta?.gqlQuery ?? meta?.gqlMutation;\n\n  if (gqlOperation) {\n    const singularResourceName = camelcase(singular(resource), {\n      pascalCase: true,\n    });\n\n    const operationName = `Created${singularResourceName}`;\n\n    const operation = `created${singularResourceName}`;\n\n    const query = `\n            subscription ${operationName}($input: Create${singularResourceName}SubscriptionFilterInput) {\n                ${operation}(input: $input) {\n                    ${getOperationFields(gqlOperation)}\n                }\n            }\n        `;\n\n    const variables: VariableOptions = {};\n\n    if (filters) {\n      variables[\"input\"] = {\n        filter: generateFilters(\n          filters.filter(\n            (filter: LogicalFilter) => !filter.field.includes(\".\"),\n          ),\n        ),\n      };\n    }\n\n    return { query, variables, operation, operationName };\n  }\n\n  const operation = `created${camelcase(singular(resource), {\n    pascalCase: true,\n  })}`;\n\n  const queryVariables: VariableOptions = {};\n\n  if (filters) {\n    queryVariables[\"input\"] = {\n      type: camelcase(\n        `create_${singular(resource)}_subscription_filter_input`,\n        {\n          pascalCase: true,\n        },\n      ),\n      required: true,\n      value: {\n        filter: generateFilters(\n          filters.filter(\n            (filter: LogicalFilter) => !filter.field.includes(\".\"),\n          ),\n        ),\n      },\n    };\n  }\n\n  const { query, variables } = gql.subscription({\n    operation,\n    fields: meta.fields,\n    variables: queryVariables,\n  });\n\n  return { query, variables, operation };\n};\n\nexport const generateUpdatedSubscription = ({\n  id,\n  resource,\n  filters,\n  meta,\n}: any) => {\n  const gqlOperation = meta?.gqlQuery ?? meta?.gqlMutation;\n\n  if (gqlOperation) {\n    const singularResourceName = camelcase(singular(resource), {\n      pascalCase: true,\n    });\n\n    const operationName = `Updated${singularResourceName}`;\n\n    const operation = `updatedOne${singularResourceName}`;\n\n    const query = `\n            subscription ${operationName}($input: UpdateOne${singularResourceName}SubscriptionFilterInput) {\n                ${operation}(input: $input) {\n                   ${getOperationFields(gqlOperation)}\n                }\n            }\n        `;\n\n    const variables: VariableOptions = {};\n\n    if (filters) {\n      variables[\"input\"] = {\n        filter: generateFilters(\n          filters.filter(\n            (filter: LogicalFilter) => !filter.field.includes(\".\"),\n          ),\n        ),\n      };\n    }\n\n    if (id) {\n      variables[\"input\"] = {\n        filter: {\n          id: { eq: id },\n        },\n      };\n    }\n\n    return { query, variables, operation, operationName };\n  }\n\n  const operation = `updatedOne${camelcase(singular(resource), {\n    pascalCase: true,\n  })}`;\n\n  const queryVariables: VariableOptions = {};\n\n  if (filters) {\n    queryVariables[\"input\"] = {\n      type: camelcase(\n        `update_one_${singular(resource)}_subscription_filter_input`,\n        {\n          pascalCase: true,\n        },\n      ),\n      required: true,\n      value: {\n        filter: generateFilters(\n          filters.filter(\n            (filter: LogicalFilter) => !filter.field.includes(\".\"),\n          ),\n        ),\n      },\n    };\n  }\n\n  if (id) {\n    queryVariables[\"input\"] = {\n      type: camelcase(\n        `update_one_${singular(resource)}_subscription_filter_input`,\n        {\n          pascalCase: true,\n        },\n      ),\n      required: true,\n      value: {\n        filter: {\n          id: { eq: id },\n        },\n      },\n    };\n  }\n\n  const { query, variables } = gql.subscription({\n    operation,\n    fields: meta.fields,\n    variables: queryVariables,\n  });\n\n  return { query, variables, operation };\n};\n\nexport const generateDeletedSubscription = ({\n  resource,\n  filters,\n  meta,\n}: any) => {\n  if (meta?.gqlQuery) {\n    const singularResourceName = camelcase(singular(resource), {\n      pascalCase: true,\n    });\n\n    const operationName = `Deleted${singularResourceName}`;\n\n    const operation = `deletedOne${singularResourceName}`;\n\n    const query = `\n            subscription ${operationName}($input: DeleteOne${singularResourceName}SubscriptionFilterInput) {\n                ${operation}(input: $input) {\n                    id\n                }\n            }\n        `;\n\n    const variables: VariableOptions = {};\n\n    if (filters) {\n      variables[\"input\"] = {\n        filter: generateFilters(\n          filters.filter(\n            (filter: LogicalFilter) => !filter.field.includes(\".\"),\n          ),\n        ),\n      };\n    }\n\n    return { query, variables, operation, operationName };\n  }\n\n  const operation = `deletedOne${camelcase(singular(resource), {\n    pascalCase: true,\n  })}`;\n\n  const queryVariables: VariableOptions = {};\n\n  if (filters) {\n    queryVariables[\"input\"] = {\n      type: camelcase(\n        `delete_one_${singular(resource)}_subscription_filter_input`,\n        {\n          pascalCase: true,\n        },\n      ),\n      required: true,\n      value: {\n        filter: generateFilters(\n          filters.filter(\n            (filter: LogicalFilter) => !filter.field.includes(\".\"),\n          ),\n        ),\n      },\n    };\n  }\n\n  const { query, variables } = gql.subscription({\n    operation,\n    fields: meta.fields.filter(\n      (field: string | object) => typeof field !== \"object\",\n    ),\n    variables: queryVariables,\n  });\n\n  return { query, variables, operation };\n};\n","import { FieldNode, DocumentNode, visit, SelectionSetNode } from \"graphql\";\n\nconst getChildNodesField = (node: FieldNode): FieldNode | undefined => {\n  return node?.selectionSet?.selections?.find(\n    (node) => node.kind === \"Field\" && node.name.value === \"nodes\",\n  ) as FieldNode;\n};\n\nexport const getOperationFields = (documentNode: DocumentNode) => {\n  const fieldLines: string[] = [];\n  let isInitialEnter = true;\n  let depth = 0;\n  let isNestedField = false;\n\n  visit(documentNode, {\n    Field: {\n      enter(node): SelectionSetNode | void {\n        if (isInitialEnter) {\n          isInitialEnter = false;\n\n          const childNodesField = getChildNodesField(node);\n\n          const nodeToReturn = childNodesField ?? node;\n\n          if (typeof nodeToReturn.selectionSet === \"undefined\") {\n            throw new Error(\"Operation must have a selection set\");\n          }\n\n          return nodeToReturn.selectionSet;\n        }\n\n        fieldLines.push(\n          `${depth > 0 ? \"  \".repeat(isNestedField ? depth : depth - 1) : \"\"}${\n            node.name.value\n          }${node.selectionSet ? \" {\" : \"\"}`,\n        );\n\n        if (node.selectionSet) {\n          depth++;\n          isNestedField = true;\n        }\n      },\n      leave(node) {\n        if (node.selectionSet) {\n          depth--;\n          fieldLines.push(`${\"  \".repeat(depth)}}`);\n          isNestedField = false;\n        }\n      },\n    },\n  });\n\n  return fieldLines.join(\"\\n\").trim();\n};\n\nexport const isMutation = (documentNode: DocumentNode) => {\n  let isMutation = false;\n\n  visit(documentNode, {\n    OperationDefinition: {\n      enter(node) {\n        if (node.operation === \"mutation\") {\n          isMutation = true;\n        }\n      },\n    },\n  });\n\n  return isMutation;\n};\n","import { LiveProvider } from \"@refinedev/core\";\n\nimport { Client } from \"graphql-ws\";\n\nimport { generateSubscription } from \"../utils\";\n\ntype SubscriptionAction = \"created\" | \"updated\" | \"deleted\";\n\nexport const liveProvider = (client: Client): LiveProvider => {\n  const subscribeToResource = (\n    client: Client,\n    callback: Function,\n    params: any,\n    meta: any,\n    action: SubscriptionAction,\n    resource: string,\n    unsubscribes: Function[],\n  ) => {\n    const unsubscribe = generateSubscription(\n      client,\n      { callback, params, meta },\n      action,\n    );\n    unsubscribes.push(unsubscribe);\n  };\n\n  return {\n    subscribe({ callback, params, meta }) {\n      const { resource, subscriptionType } = params ?? {};\n\n      if (!meta || !subscriptionType || !resource) {\n        throw new Error(\n          \"[useSubscription]: `meta`, `subscriptionType` and `resource` are required in `params` for graphql subscriptions\",\n        );\n      }\n\n      const unsubscribes: any[] = [];\n\n      if (params?.subscriptionType === \"useList\") {\n        [\"created\", \"updated\", \"deleted\"].forEach((action) =>\n          subscribeToResource(\n            client,\n            callback,\n            params,\n            meta,\n            action as SubscriptionAction,\n            resource,\n            unsubscribes,\n          ),\n        );\n      }\n\n      if (params?.subscriptionType === \"useOne\") {\n        subscribeToResource(\n          client,\n          callback,\n          params,\n          meta,\n          \"updated\",\n          resource,\n          unsubscribes,\n        );\n      }\n\n      const unsubscribe = () => {\n        unsubscribes.forEach((unsubscribe) => unsubscribe());\n      };\n\n      return unsubscribe;\n    },\n    unsubscribe(unsubscribe) {\n      unsubscribe();\n    },\n  };\n};\n","import dataProvider from \"./dataProvider\";\n\nexport * from \"./dataProvider\";\nexport * from \"./interfaces\";\nexport * from \"./liveProvider\";\nexport * as qqlQueryBuilder from \"gql-query-builder\";\nexport type {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  GraphQLWebSocketClient,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from \"graphql-request\";\nexport {\n  batchRequests,\n  gql,\n  GraphQLClient,\n  rawRequest,\n  request,\n  resolveRequestDocument,\n} from \"graphql-request\";\nexport * as graphqlWS from \"graphql-ws\";\n\nexport default dataProvider;\n","import createRequestBody from './createRequestBody.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type * as Dom from './types.dom.js'\nimport type {\n  HTTPMethodInput,\n  MaybeFunction,\n  RequestConfig,\n  RequestMiddleware,\n  Response,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\nimport type { T, V } from 'vitest/dist/types-7cd96283.js'\n\nexport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n}\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers: Dom.RequestInit['headers']): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: Dom.RequestInit) => Promise<Dom.Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: Dom.RequestInit\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: Dom.RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<Response<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(\n    documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>,\n    requestHeaders?: Dom.RequestInit['headers']\n  ): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: Dom.RequestInit['headers']): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: Dom.RequestInit\n  middleware?: RequestMiddleware<V>\n}): Promise<Response<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nexport const rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<Response<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\nexport async function request<T, V extends Variables = Variables>(\n  url: string,\n  // @ts-ignore\n  document: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  options: RequestExtendedOptions<V, T>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  urlOrOptions: string | RequestExtendedOptions<V, T>,\n  // @ts-ignore\n  document?: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T> {\n  // @ts-ignore\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nexport const batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: Dom.RequestInit['headers']]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nexport default request\n\nconst getResult = async (\n  response: Dom.Response,\n  jsonSerializer: Dom.JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeFunction<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: any[]): string => {\n  return chunks.reduce(\n    (accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\n"],"mappings":"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","names":["import_camelcase","gql","import_graphql_tag","import_pluralize","import_camelcase","gql","import_set","import_pluralize","import_graphql","getChildNodesField","node","_a","_b","getOperationFields","documentNode","fieldLines","isInitialEnter","depth","isNestedField","nodeToReturn","isMutation","generateSubscription","client","callback","params","meta","type","generatorMap","generateCreatedSubscription","generateUpdatedSubscription","generateDeletedSubscription","resource","filters","subscriptionType","id","ids","generator","operation","query","variables","operationName","onNext","payload","operatorMap","operatorMapper","operator","value","generateFilters","result","f","filter","set","generateSorting","sorters","sorter","generatePaging","pagination","gqlOperation","singularResourceName","camelcase","getOperationFields","queryVariables","field","dataProvider","client","resource","pagination","sorters","filters","meta","operation","camelcase","paging","generatePaging","queryVariables","query","variables","generateFilters","generateSorting","gqlQuery","response","ids","gqlOperation","id","pascalResource","mutationOperation","mutation","gqlTag","isMutation","stringFields","getOperationFields","url","method","headers","gqlMutation","dataProvider_default","liveProvider","client","subscribeToResource","callback","params","meta","action","resource","unsubscribes","unsubscribe","generateSubscription","subscriptionType","qqlQueryBuilder","import_createRequestBody","import_defaultJsonSerializer","import_helpers","import_parseArgs","import_resolveRequestDocument","import_types","CrossFetch","import_graphql_ws","resolveHeaders","headers","oHeaders","CrossFetch","name","value","cleanQuery","str","buildRequestConfig","params","params_","search","payload","acc","currentQuery","index","createHttpMethodFetcher","method","url","query","variables","operationName","fetch","fetchOptions","middleware","queryParams","body","createRequestBody","init","urlResolved","initResolved","result","urlNew","initNew","GraphQLClient","requestConfig","args","queryOrOptions","requestHeaders","rawRequestOptions","crossFetch","requestMiddleware","responseMiddleware","makeRequest","callOrIdentity","response","error","documentOrOptions","variablesAndRequestHeaders","requestOptions","documentsOrOptions","batchRequestOptions","queries","document","key","fetcher","isBatchingQuery","getResult","successfullyReceivedData","data","successfullyPassedErrorPolicy","errors","rest","errorResult","rawRequest","urlOrOptions","request","batchRequests","parseBatchRequestsArgsExtended","getResult","response","jsonSerializer","contentType","value","key","callOrIdentity","gql","chunks","variables","accumulator","chunk","index","graphqlWS","src_default","dataProvider_default"]}